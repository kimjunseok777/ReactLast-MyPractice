


앞에서 AuthApi 사용해서 회원가입 로직 만드는 것까지 진행했었다

이제 로그인 만들고, 투두 만들고, React Query 로 넘어갈 것이다


===================================================================================================


** 경로 이동 : sign-in-form.jsx

        -->  apis 에서 auth.api.js 에서 만들어준 로그인 요청 기능 그대로 import 받아서 사용하면 된다
                ex) AuthApi.signIn({ email , password ... })

        -->  handlePressSignIn 함수에 fetch 로 msw 에 데이터 요청했던 것 다 지워주고, axios 로 만들어준 모듈화 기능들 사용해주자

        -->  로그인 기능이나 회원가입 기능은 JwtAuth 미들웨어가 적용되면 안된다
                토큰이 발급되기 전에 있을 기능들 (로그인, 회원가입) 인데, 토큰이 있어야된다는 오류가 뜨게 된다


===================================================================================================


** 경로 이동 : sign-in-form.jsx

        -->  이제 토큰을 관리해볼 것이다  -->  관리하는 방법 : cookie , local storage

        ) local storage : 웹 브라우저 내부에 있는 저장소  -->  개발자 모드에서 Application 에 local storage 에서 확인이 가능하다
                                    (이 공간에 key 와 value 값이 저장이 되고, 마음대로 가져다 쓸 수 있다)  -->  localStorage 에서 getItem, setItem ... 등의 옵션들로 관리할 수 있다
                                    -->  local storage 는 웹 브라우저가 꺼져도 계속 유지가 된다  -->  ex) 웹 브라우저가 꺼져도 로그인이 계속 유지되게 만들 수 있다

        ) cookie : 마찬가지로 개발자모드 Application 의 Cookies 에서 확인이 가능하다  -->  name 과 value 로 저장한다
                         react-cookie 라는 라이브러리를 설치해야한다
                         -->  쿠키로 입력을 하게 되면 굳이 헤더에 토큰을 담지 않아도, 데이터가 알아서 전송이 된다 (쿠키가 알아서 간다)
                         -->  이 옵션이 withCredentials: true 이다 (자동으로 데이터가 전송된다  -->  token)  -->  axios.create() 이 부분에서 옵션 넣어줬다


** 경로 이동 : base.js

        -->  withCredentials 옵션 넣어주자

        -->  토큰 저장하는 방법 익혀보자 (cookie 말고 localStorage 사용할 것이다)


** 경로 이동 : sign-in-form.jsx

        토큰에 데이터 넣는 방법 ex)
                localStorage.setItem( "key 값" , JSON.stringify({
                        token: ~,
                        info: ~,
                        ... 저장소에 넣어줄 값들 작성하면 된다
                }))

        -->  토큰을 저장하는 요직을 만들어보자

        -->  localStorage.setItem() 입력해주자  -->  localStorage 에 저장하는 것이다 (key 와 value 가 입력이되면, 자동으로 set 이 되는 것이다)

        -->  로그인을 누르는 순간, 상단에 "000 님 반갑습니다" 라고 화면이 바껴야한다면 어떻게 해야할까?  -->  전역상태로 만들어서 관리해야한다
                하지만 상태의 치명적 단점이 있다  -->  새로고침하면 다 초기화된다  -->  토큰뿐만 아니라, 유저에 관한 정보들 모두 localStorage 에 저장해줄 것이다
                (token 뿐만 아니라 info 정보도 함께 localStorage 에 넣어주자)

        -->  localStorage 로 유저 정보 (token, info) 를 set 했다  -->  이제 이걸 전역상태관리 해야한다  -->  contextAPI 를 사용할 것이다


===================================================================================================


** 경로 이동 : providers  -->  auth-provider.js

        -->  react 에 내장되어 있는 contextAPI 로 전역상태관리 해주자  -->  localStorage 에 있는 user 의 info 데이터를 담아주는 역할을 할 것이다

        -->  localStorage.getItem()  -->  로컬스토리지에 있는 데이터 가져오기 위해 "getItem" 사용해줬다

        -->  user 상태 만들어서 provider 만들고 전역상태 관리 만들어주자

        -->  App.js 로 가서 사용할 스코프 Provider 로 감싸주자

        -->  info 데이터가 화면에 나오게 하고, 새로고침 해도 UI 가 유지되게 만들어줄 것이다
                (useEffect 를 사용했기에, 이제 localStorage 에 user 가 있으면 데이터가 새로고침해도 유지된다)


** 경로 이동 : sign-in-form.jsx

        -->  유저 정보 전역상태 관리로 사용해주기 위해, 전역상태 관리 useAuth 를 import 받아서 사용해주자

        -->  setUser 에 유저 info 정보를 넣어주자  -->  로그인 성공하면 유저 정보가 전역상태에 담기는 것이다

        -->  이제 헤더에다가 로그인 했을 때, 텍스트 변할 수 있게 해줄 것이다


===================================================================================================


** 경로 이동 : layouts  -->  layout.jsx

        -->  마찬가지로 전역상태고나리 useAuth 사용해주자  -->  이 전역상태는 로그인하면 유저의 정보가 담긴다  -->  setUser(info)

        -->  단순 텍스트가 바뀌는 것이 아니라, 로그아웃 버튼이 생기는 것일 수도 있다
                버튼을 누르면 setUser 랑 localStorage 에 값 모두 비워줘야되는 것이다  -->  로그아웃 만드는 것도 간단하게 작성만 해보자

        -->  이제 로그인 하면 상단에 헤더 바뀌는 것을 확인할 수 있다  -->  하지만 상태이기에 새로고침 한번이면 사라진다

        -->  Provider 로 가서 useEffect 사용해주면 재랜더링이 일어나도 로그인한 상태가 바뀌지 않게 해줄 수 있다


** 경로 이동 : providers  -->  auth-provider.js

        -->  useEffect 사용해주자 (새로고침해도 레이아웃의 info 가 사라지지 않게끔 만들어주기 위함이다  -->  useEffect 와 localStorage 의 유저 정보를 활용할 것이다)

        -->  getItem 으로 localStorage 의 데이터 가져와서 또다시 user 전역상태에 넣어줄 것이다
                ) 즉, localStorage 에 값이 있다면 랜더링 또는 새로고침 될 때마다 값이 넣어지는 것이다

        -->  이제 로그인 후에 새로고침 해도, 로그인 정보가 상태에 유지되는 것을 확인할 수 있다  -->  로그아웃 하고 싶으면 localStorage 에 있는 값 delete 해주면 된다

        -->  여기서 localStorage 에 "user" 라는 key 값으로 여러군데 쓰이는 것을 확인할 수 있다 (getItem, setItem ... 등등 user 키값으로 여러군데 만들어줬다)

        -->  이렇게 여러군데 같은 key 값이 쓰이는 것은 관심사 분리  -->  즉, 모듈화 해주는 것이 좋다 (지금은 모듈화하지 않을 것이다)


===================================================================================================



) 내용 정리 :

        1. 웹 스토리지를 통해 유저의 정보를 저장한 이유는 무엇일까?
                -->  만약에 변수나 상태로 저장하면 새로고침이 되면 값이 삭제되기 때문
                -->  백엔드 데이터 요청할 때마다 헤더에 토큰 값을 실어줘야 하기 때문

        2. 유저의 정보를 전역상태로 저장한 이유는 무엇일까?
                -->  헤더의 레이아웃에 리랜더링을 통한 인터페이스의 변화가 있기 때문
                -->  나는 상태를 왜 사용하는가?  -->  사용자에게 인터페이스 다르게 보여주기 위해서



===================================================================================================


** 경로 이동 : base.js

        인증토큰을 백엔드에 보내는 방법을 공부해볼 것이다


        ) 1. 헤더에 보내는 방법 :

                -->  이제 백엔드에 데이터 헤더 실어서 보내주는 것을 해볼 것이다  -->  백엔드에 토큰 실어서 보내는 것 해볼 것이다

                -->  baseHttp 에 있는 axios 의 create 부분에 header 에 토큰을 실어서 보내면 안된다

                -->  즉, 처음 로그인이 안되어있을 때는 undefined 이기 때문에 실행을 하지 않는다

                순서 )
                로그인 이전에 baseHttp 에 axios.create 가 할당된다  -->  새로고침을 하기 전까지 baseHttp 의 localStorage.getItem("user").token 은 undefined 이다
                -->  새로고침을 하면 변수를 다시 평가, 선언하니까 undefined 가 풀린다, 하지만 로그인 이전이라면 undefined 이다
                -->  이렇게 하려면 변수를 재할당해주거나, baseHttp 를 함수형태로 만들어서 다시 실행해줘야 한다  -->  비효율적이다


        ) 2. 인터셉트 :

                -->  인터셉트는 가로채는 것을 의미한다

                순서 )
                사용자가 request 를 보낸다  -->  인터셉트로 request 가로채서 access_token 을 넣는다  -->  request 백엔드에 보낸다

                -->  baseHttp 에서 interceptors 옵션을 사용해주자

                -->  매번 JSON.parse(localStorage.getItem("user")) 이거 해주기 귀찮으니 모듈화 해주는 것이 좋다

                -->  리프레쉬도 참고만해서 공부해보자 (실제로는 백엔드가 리프레쉬토큰 전달해주는 역할도 하는 것이다)

                -->  axios 공식 홈페이지에서 인터셉터 확인해보자

                ) 리프레쉬 토큰의 핵심 :
                        -->  백엔드와의 에러코드 공유
                        -->  응답을 받기 전에, 리프레쉬는 있는데 토큰이 유효하지 않은 경우에 맞는 분기 처리
                        -->  리프레쉬토큰을 통해, 인증토큰을 재발급 받고 재요청  -->  return baseHttp(error.config)
                                "재요청" 하는 이유는 사용자는 자신이 토큰을 재발급 받았다는 사실을 몰라야하니까이다

                ) 리프레쉬토큰 : 백엔드가 지정해준 에러코드에 따라서 분기를 처서 다시 재발급 받거나, 아예 로그아웃을 시켜주는 것이구나라고 알고 있으면 된다


===================================================================================================


                리프레쉬토큰은 로그인할 때 인증토큰과 같이 발급 된다

                ) 백엔드에서 직접 쿠키로 내려주는 경우  -->  프론트엔드는 withCredentials 만 true 로 해주고 가만히 있으면 된다  (가장 많이 쓰이는 방법)

                ) 백엔드에서 body 에 내려주는 경우  -->  백엔드가 부탁 (cookie 또는 header 에 넣어서 주세요 ... 등등)
                                                                           -->  리프레쉬토큰까지 header 에 넣어서 보내는 방법은 좋지 않다
                                                                           -->  어쨌든 이처럼, 프론트엔드가 직접 쿠키를 세팅하는 경우가 생길 수도 있다  -->  cookie.set() 사용하면 된다

                어세스 토큰 같은 경우는 프론트가 헤더에 실어서 보내야한다


===================================================================================================


) 토큰 복습 :

        사용자는 백엔드에게 요청할 때마다 access_token 을 실어서 보내야한다 (내가 나임을 증명해야하기 때문)
        백엔드는 access_token 을 받아서 이 사용자가 누구인지 판단을 한다

        access_token 의 단점은 다른사람이 가져가서 나인척 할 수도 있다 (CSRF 공격이라고 한다)
        나인척을 못하도록 이 access_token 유효기간을 짧게 설정해야한다  -->  짧게 설정했기 때문에 백엔드에서 응답이 왔을 때 토큰의 시간이 초과되면 에러가 발생한다
        이럴때 만약 5분마다 로그아웃 되면 정말 불편하다  -->  이렇기에 우리는 여기서 refresh_token 이라는 친구를 사요하는 것이다

        refresh_token 은 유효기간이 access_token 보다 더 길다  -->  하지만 이 refresh_token 은 인증인가에 사용되지는 않는다
        즉, refresh 가 있다면 백엔드에게 access 다시 발급하라고 요청하는 것이다  -->  이러면 access_token 을 다시 set 해주고 기존에 있었던 요청을 다시 보내주는 것이다
        --> 이때는 access_token 이 새삥이니까 에러가 나지 않게 되는 것이다 (재발급 받은 access_token 이기에 에러가 나지 않는 것이다)

        ==>  이것이 기본적인 "인증 / 인가 로직" 이다  ***


) 그림 복습 :

        client (access_token)  ----------------->  request  ----------------->  backend
                   (error 가 발생함)  <----------------  response  -----------------
                   이제 여기서 refresh 가 있는지 없는지에 따라서 분기가 발생하는 것이다
                   ) 분기 : refresh( o )  -->  logout
                               refresh( x )  -->  access_token 재발급  -->  백엔드에게 재발급 요청을 한다
                                                <----------------  재발급 받는 response  ------
                                                재발급 받은 access_token 이 세팅됨
                                                기존에 에러 났었던 request 를 백엔드에게 보낸다  -->  backend
                                                <----------------  response  -----------------  (기존에 토큰 유효기간 다 돼서 에러났었던 응답을 다시 보내는 것이다)
                        

===================================================================================================


** 경로 이동 : 


===================================================================================================


** 경로 이동 : 


===================================================================================================


** 경로 이동 : 


===================================================================================================